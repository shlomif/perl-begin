<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content="HTML Tidy for Linux/x86 (vers 25 March 2009), see www.w3.org" />
<title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../styles/style.css" type="text/css" />
</head>
<body>
<h2 id="heading_id_2">What's Missing</h2>
<p>Perl 5 isn't perfect, at least as it behaves by default. Some options are available in the core. More are available from the CPAN. Experienced Perl developers have their own idea of how an ideal Perl 5 should behave, and they often use their own configurations very effectively.</p>
<p>Novices may not know how Perl can help them write programs better. A handful of core modules will make you much more productive.</p>
<h3 id="heading_id_3">Missing Defaults</h3>
<div id="missing_defaults"></div>
<p>Perl 5's design process in 1993 and 1994 tried to anticipate new directions for the language, but it's impossible to predict the future. Perl 5 added many great new features, but it also kept compatibility with the previous seven years of Perl 1 through Perl 4. Sixteen years later, the best way to write clean, maintainable, powerful, and succinct Perl 5 code is very different from Perl 5.000. The default behaviors sometimes get in the way; fortunately, better behaviors are available.</p>
<h4 id="heading_id_4">The strict Pragma</h4>
<div id="istrict_0"></div>
<div id="imodules__istrict_0"></div>
<div id="ipragmas__istrict_0"></div>
<p>The <code>strict</code> pragma (<a href="chapter_09.html#pragmas">Pragmas</a>(pragmas)) allows you to forbid (or re-enable) various language constructs which offer power but also the potential for accidental abuse.</p>
<p><code>strict</code> performs three functions: forbidding symbolic references, requiring variable declarations, and forbidding the use of undeclared barewords (<a href="chapter_11.html#barewords">Barewords</a>(barewords)). While the occasional use of symbolic references is necessary to perform symbol-table manipulation and exporting (barring the use of helper modules, such as <code>Moose</code>), the use of a variable as a variable name offers the possibility of subtle errors of action at a distance--or, worse, the possibility of poorly validated user input manipulating internal-only data for malicious purposes.</p>
<p>Requiring variable declarations helps to prevent typos in variable names and encourages proper scoping of lexical variables. It's much easier to see the intended scope of a lexical variable if all variables have <code>my</code> or <code>our</code> declarations in the appropriate scope.</p>
<p><code>strict</code> has a lexical effect, based on the compile-time scope of its use. You may disable certain features of <code>strict</code> (within the smallest possible scope, of course) with <code>no strict</code>. See <code>perldoc strict</code> for more details.</p>
<h4 id="heading_id_5">The warnings Pragma</h4>
<p>The <code>warnings</code> pragma (<a href="chapter_09.html#handling_warnings">Handling Warnings</a>(handling_warnings)) controls the reporting of various classes of warnings in Perl 5, such as attempting to stringify the <code>undef</code> value or using the wrong type of operator on values. It also warns about the use of deprecated features.</p>
<p>The most useful warnings explain that Perl had trouble understanding what you meant and had to guess at the proper interpretation. Even though Perl often guesses correctly, disambiguation on your part will ensure that your programs run correctly.</p>
<p>The <code>warnings</code> pragma has a lexical effect on the compile-time scope of its use. You may disable some or all warnings with <code>no warnings</code> (within the smallest possible scope, of course). See <code>perldoc perllexwarn</code> and <code>perldoc warnings</code> for more details.</p>
<div class="sidebar">
<p>Combine <code>use warnings</code> with <code>use diagnostics</code>, and Perl 5 will display expanded diagnostic messages for each warning present in your programs. These expanded diagnostics come from <code>perldoc perldiag</code>. This behavior is useful when learning Perl, but it's less useful in code deployed to production, because it can produce verbose error output.</p>
</div>
<h4 id="heading_id_6">IO::Handle</h4>
<p>Perl 5.6.0 added lexical filehandles. Previously, filehandles were all package globals. This was occasionally messy and often confusing. Now that you can write:</p>
<div class="programlisting">
<pre>
<code>    open my $fh, '&gt;', $file or die "Can't write to '$file': $!\n";</code>
</pre></div>
<p>... the lexical filehandle in <code>$fh</code> is easier to use. The implementation of lexical filehandles creates objects; <code>$fh</code> is an instance of <code>IO::Handle</code>. Unfortunately, even though <code>$fh</code> is an object, you can't call methods on it because nothing has loaded the <code>IO::Handle</code> class.</p>
<p>This is occasionally painful when you want to flush the buffer of the associated filehandle, for example. It could be as easy as:</p>
<div class="programlisting">
<pre>
<code>    $fh-&gt;flush();</code>
</pre></div>
<p>... but only if your program somewhere contains <code>use IO::Handle</code>. The solution is to add this line to your programs so that lexical filehandles--the objects as they are--behave as objects should behave.</p>
<h4 id="heading_id_7">The autodie Pragma</h4>
<div id="autodie"></div>
<div id="iautodie_0"></div>
<div id="ipragmas__iautodie_0"></div>
<p>Perl 5's default error checking is parsimonious. If you're not careful to check the return value of every <code>open()</code> call, for example, you could try to read from a closed filehandle--or worse, lose data as you try to write to one. The <code>autodie</code> pragma changes the default behavior. If you write:</p>
<div class="programlisting">
<pre>
<code>    use autodie;

    open my $fh, '&gt;', $file;</code>
</pre></div>
<p>... an unsuccessful <code>open()</code> call will throw an exception via Perl 5's normal exception mechanism. Given that the most appropriate approach to a failed system call is throwing an exception, this pragma can remove a lot of boilerplate code and allow you the peace of mind of knowing that you haven't forgotten to check a return value.</p>
<p>This pragma entered the Perl 5 core as of Perl 5.10.1. See <code>perldoc autodie</code> for more information.</p>
</body>
</html>
