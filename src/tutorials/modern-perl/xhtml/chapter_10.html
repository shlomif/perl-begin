<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content="HTML Tidy for Linux/x86 (vers 25 March 2009), see www.w3.org" />
<title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../styles/style.css" type="text/css" />
</head>
<body>
<h2 id="heading_id_2">Perl Beyond Syntax</h2>
<p>Perl 5 is a large language, like any language intended to solve problems in the real world. Effective Perl programs require more than mere understanding of syntax; you must also begin to understand how Perl's features interact and common ways of solving well-understood problems in Perl.</p>
<p>Prepare for the second learning curve of Perl: thinking Perlishly through the effective use of common patterns of behavior and builtin shortcuts which, when used well, allow you to write concise, powerful code.</p>
<h3 id="heading_id_3">Idioms</h3>
<div id="idioms"></div>
<p>Any language--programming or natural--develops <i>idioms</i>, or common patterns of expression. The earth revolves, but we speak of the sun rising or setting. We talk of clever hacks and nasty hacks and slinging code.</p>
<p>As you learn Perl 5 more clearly, you will begin to see and understand common idioms. They're not quite language features--you don't <i>have</i> to use them--and they're not quite large enough that you can encapsulate them away behind functions and methods. Instead, they're mannerisms. They're ways of writing Perl with a Perlish accent.</p>
<h4 id="heading_id_4">The Object as $self</h4>
<div id="i36self_0"></div>
<div id="ivariables__i36self_0"></div>
<div id="iobjects__iinvocant_0"></div>
<div id="imethods__iinvocant_0"></div>
<p>Perl 5's object system (<a href="chapter_07.html#moose">Moose</a>(moose)) treats the invocant of a method as a mundane parameter. The invocant of a class method--a string containing the name of the class--is that method's first parameter. The invocant of an object or instance method--the object itself--is that method's first parameter. You are free to use or ignore it as you see fit.</p>
<p>Idiomatic Perl 5 uses <code>$class</code> as the name of the class method and <code>$self</code> for the name of the object invocant. This is a convention not enforced by the language itself, but it is a convention strong enough that useful extensions such as <code>MooseX::Method::Signatures</code> assume you will use <code>$self</code> as the name of the invocant by default.</p>
<h4 id="heading_id_5">Named Parameters</h4>
<div id="iparameters__inamed_0"></div>
<div id="iarguments__inamed_0"></div>
<div id="isignatures_0"></div>
<div id="iMooseX5858MultiMethods_0"></div>
<p>Without a module such as <code>signatures</code> or <code>MooseX::Multimethods</code>, Perl 5's argument passing mechanism is simple: all arguments flatten into a single list accessible through <code>@_</code> (<a href="chapter_05.html#function_parameters">Function Parameters</a>(function_parameters)). While this simplicity is occasionally too simple--named parameters can be very useful at times--it does not preclude the use of idioms to provide named parameters.</p>
<p>The list context evaluation and assignment of <code>@_</code> allows you to unpack named parameters as pairs in a natural and Perlish fashion. Even though this function call is equivalent to passing a comma-separated or <code>qw//</code>-created list, arranging the arguments as if they were true pairs of keys and values makes the caller-side of the function appear to support named parameters:</p>
<div class="programlisting">
<pre>
<code>    make_ice_cream_sundae(
        whipped_cream =&gt; 1,
        sprinkles     =&gt; 1,
        banana        =&gt; 0,
        ice_cream     =&gt; 'mint chocolate chip',
    );</code>
</pre></div>
<p>The callee side can unpack these parameters into a hash and treat the hash as if it were the single argument:</p>
<div class="programlisting">
<pre>
<code>    sub make_ice_cream_sundae
    {
        <b>my %args = @_;</b>

        my $ice_cream = get_ice_cream( $args{ice_cream}) );
        ...
    }</code>
</pre></div>
<div class="sidebar">
<p><i>Perl Best Practices</i> suggests passing a hash reference instead. This allows Perl to check that you've constructed a valid hash on the caller side. It also uses slightly less memory than the other approach.</p>
</div>
<p>This technique works well with <code>import()</code> (<a href="chapter_05.html#importing">Importing</a>(importing)); you can process as many parameters as you like before slurping the remainder into a hash:</p>
<div class="programlisting">
<pre>
<code>    sub import
    {
        <b>my ($class, %args)  = @_;</b>
        my $calling_package = caller();

        ...
    }</code>
</pre></div>
<h4 id="heading_id_6">The Schwartzian Transform</h4>
<div id="schwartzian_transform"></div>
<p>People new to Perl sometimes overlook the importance of lists and list processing as a fundamental component of expression evaluation. Put more simply, the ability for Perl programmers to chain expressions which evaluate to variable-length lists provides countless opportunities to manipulate data effectively.</p>
<div id="iSchwartzian_transform_0"></div>
<div id="imap__iSchwartzian_transform_0"></div>
<div id="isort__iSchwartzian_transform_0"></div>
<p>The <i>Schwartzian transform</i> is an elegant demonstration of that principle as an idiom handily borrowed from the Lisp family of languages.</p>
<p>Suppose you have a Perl hash which associates the names of your co-workers with their phone extensions:</p>
<div class="programlisting">
<pre>
<code>    my %extensions =
    (
         4 =&gt; 'Jerryd',
         5 =&gt; 'Rudy',
         6 =&gt; 'Juwan',
         7 =&gt; 'Brandon',
        10 =&gt; 'Joel',
        21 =&gt; 'Marcus',
        24 =&gt; 'Andre',
        23 =&gt; 'Martell',
        52 =&gt; 'Greg',
        88 =&gt; 'Nic',
    );</code>
</pre></div>
<p>Suppose you want to print a list of extensions and co-workers sorted by their names, not their extensions. In other words, you need to sort this hash by its values. Sorting the values of the hash in string order is easy:</p>
<div class="programlisting">
<pre>
<code>    my @sorted_names = sort values %extensions;</code>
</pre></div>
<p>... but that loses the association of names with extensions. Instead, use the Schwartzian transform to transform the data before and after sorting it to preserve the necessary information. First, convert the hash into a list of data structures which contain the vital information in sortable fashion. In this case, convert the hash pairs into two-element anonymous arrays:</p>
<div class="programlisting">
<pre>
<code>    my @pairs = map { [ $_, $extensions{$_} ] } keys %extensions;</code>
</pre></div>
<div class="sidebar">
<p>Reversing the hash <i>in place</i> would work if no one had the same name. This particular data set presents no such problem, but code defensively.</p>
</div>
<p><code>sort</code> takes the list of anonymous arrays and compares their second elements (the names) with a stringwise comparison:</p>
<div class="programlisting">
<pre>
<code>    my @sorted_pairs = sort { $a-&gt;[1] cmp $b-&gt;[1] } @pairs;</code>
</pre></div>
<p>Given <code>@sorted_pairs</code>, a second <code>map</code> operation converts the data structure to a more usable form:</p>
<div class="programlisting">
<pre>
<code>    my @formatted_exts = map { "$_-&gt;[1], ext. $_-&gt;[0]" } @sorted_pairs;</code>
</pre></div>
<p>... and now you can print the whole thing:</p>
<div class="programlisting">
<pre>
<code>    say for @formatted_exts;</code>
</pre></div>
<p>Of course, this uses several temporary variables (with admittedly bad names). It's a worthwhile technique and good to understand, but the real magic is in the combination:</p>
<div class="programlisting">
<pre>
<code>    say for
        map  { " $_-&gt;[1], ext. $_-&gt;[0]"          }
        sort {   $a-&gt;[1] cmp   $b-&gt;[1]           }
        map  { [ $_      =&gt;    $extensions{$_} ] }
            keys %extensions;</code>
</pre></div>
<p>Read the expression from right to left, in the order of evaluation. For each key in the extensions hash, make a two-item anonymous array containing the key and the value from the hash. Sort that list of anonymous arrays by their second elements, the values from the hash. Format a string of output from those sorted arrays.</p>
<p>The Schwartzian transform is this pipeline of <code>map</code>-<code>sort</code>-<code>map</code> where you transform a data structure into another form easier for sorting and then transform it back into your preferred form for modification.</p>
<p>This transformation is simple. Consider the case where calculating the right value to sort is expensive in time or memory, such as calculating a cryptographic hash for a large file. In that case, the Schwartzian transform is also useful because you can perform those expensive operations once (in the rightmost <code>map</code>), compare them repeatedly from a de facto cache in the <code>sort</code>, and then remove them in the leftmost <code>map</code>.</p>
<h4 id="heading_id_7">Easy File Slurping</h4>
<div id="easy_file_slurping"></div>
<div id="ilocal__i3647_0"></div>
<div id="iglobals__i3647_0"></div>
<p>Perl 5's magic global variables are truly global in many cases. It's all too easy to clobber their values elsewhere, unless you use <code>local</code> everywhere. Yet this requirement has allowed the creation of several interesting idioms. For example, you can slurp files into a scalar in a single expression:</p>
<div class="programlisting">
<pre>
<code>    my $file = do { local $/ = &lt;$fh&gt; };

    # or

    my $file = do { local $/; &lt;$fh&gt; };</code>
</pre></div>
<p><code>$/</code> is the input record separator. <code>local</code>izing it sets its value to <code>undef</code>, pending assignment. That <code>local</code>ization takes place <i>before</i> the assignment. As the value of the separator is undefined, Perl happily reads the entire contents of the filehandle in one swoop and assigns that value to <code>$/</code>. Because a <code>do</code> block evaluates to the value of the last expression evaluated within the block, this evaluates to the value of the assignment, or the contents of the file. Even though <code>$/</code> immediately reverts to its previous state at the end of the block, <code>$file</code> now contains the contents of the file.</p>
<p>The second example is similar, except that it performs no assignment and merely returns the single line read from the filehandle. You may see either example; they both work the same way in this case.</p>
<p>This can be useful (and, admittedly, maddening for people unfamiliar with this particular combination of Perl 5 features) if you don't have <code>File::Slurp</code> installed from the CPAN.</p>
<h4 id="heading_id_8">Controlled Execution</h4>
<div id="controlled_execution"></div>
<p>The effective difference between a program and a module is in its intended use. Users invoke programs directly, while programs load modules after execution has already begun. The technical difference between a program and a module is whether it's meaningful to invoke the entity directly.</p>
<p>You may encounter this when you wish to use Perl's testing tools (<a href="chapter_09.html#testing">Testing</a>(testing)) to test functions in a standalone program or when you wish to make a module users can run directly. All you need to do is to discover <i>how</i> Perl began to execute a piece of code. For this, use <code>caller</code>.</p>
<div id="icaller_1"></div>
<div id="ioperators__icaller_0"></div>
<div id="icall_frame_1"></div>
<p><code>caller</code>'s single optional argument is the number of call frames which to report. (A <i>call frame</i> is the bookkeeping information which represents a function call.) You can get information about the current call frame with <code>caller(0)</code>. To allow a module to run correctly as a program <i>or</i> a module, write an appropriate <code>main()</code> function and add a single line to the start of the module:</p>
<div class="programlisting">
<pre>
<code>    main() unless caller(0);</code>
</pre></div>
<p>If there's <i>no</i> caller for the module, someone invoked it directly as a program (with <code>perl path/to/Module.pm</code> instead of <code>use Module;</code>).</p>
<div class="sidebar">
<p>Checking the eighth element of the list returned from <code>caller</code> in list context may be more accurate in most cases, but it's rare. This value is true if the call frame represents <code>use</code> or <code>require</code> and undef otherwise.</p>
</div>
<h4 id="heading_id_9">Handling Main</h4>
<p>Perl requires no special syntax for creating closures (<a href="chapter_05.html#closures">Closures</a>(closures)); you can close over a lexical variable inadvertently. This is <i>rarely</i> a problem in practice, apart from specific concerns in mod_perl situations... and <code>main()</code> functions.</p>
<p>Many programs commonly set up several file-scoped lexical variables before handing off processing to other functions. It's tempting to use these variables directly, rather than passing values to and returning values from functions, especially as programs grow to provide more features. Worse yet, these programs may come to rely on subtleties of what happens when during Perl 5's compilation process; a variable you <i>thought</i> would be initialized to a specific value may not get initialized until much later.</p>
<p>There is a simple solution. Wrap the main code of your program in a simple function, <code>main()</code>. Encapsulate all of the variables you don't need as true globals. Then add a single line to the beginning of your program, after you've used all of the modules and pragmas you need:</p>
<div class="programlisting">
<pre>
<code>    #!/usr/bin/perl

    use Modern::Perl;
    use autodie;

    ...

    <b>main( @ARGS );</b></code>
</pre></div>
<p>Calling <code>main()</code> <i>before</i> performing anything else in the program forces you to be explicit about initialization and order of compilation. It also helps to remind you to encapsulate the behavior of your program into functions and modules. (It works nicely with files which can be programs and libraries--<a href="chapter_10.html#controlled_execution">Controlled Execution</a>(controlled_execution).)</p>
<h4 id="heading_id_10">Postfix Parameter Validation</h4>
<div id="postfix_parameter_validation"></div>
<p>Even if you don't use a CPAN module such as <code>Params::Validate</code> or <code>MooseX::Params::Validate</code> to verify that the parameters your functions receive are correct, you can still benefit from occasional checks for correctness. The <code>unless</code> control flow modifier is an easy and readable way to assert your expectations at the beginning of a function.</p>
<p>Suppose your function takes two arguments, no more and no less. You <i>could</i> write:</p>
<div class="programlisting">
<pre>
<code>    use Carp;

    sub groom_monkeys
    {
        if (@_ != 2)
        {
            croak 'Monkey grooming requires two monkeys!';
        }
    }</code>
</pre></div>
<p>... but from a linguistic perspective, the consequences are more important than the check and deserve to be at the <i>start</i> of the expression:</p>
<div class="programlisting">
<pre>
<code>    croak 'Monkey grooming requires two monkeys!' if @_ != 2;</code>
</pre></div>
<p>... which, depending on your preference for reading postfix conditions, you can simplify to:</p>
<div class="programlisting">
<pre>
<code>    croak 'Monkey grooming requires two monkeys!' unless @_ == 2;</code>
</pre></div>
<p>This is easier to read if you focus on the text of the message ("You need to pass two parameters!") and the test (<code>@_</code> should contain two items). It's almost a single row in a truth table.</p>
<h4 id="heading_id_11">Regex En Passant</h4>
<div id="regex_en_passant"></div>
<div id="iregex__imodification_0"></div>
<div id="iregex__isubstitution_0"></div>
<p>Many Perl 5 idioms rely on the language design where expressions evaluate to values, as in:</p>
<div class="programlisting">
<pre>
<code>    say my $ext_num = my $extension = 42;</code>
</pre></div>
<p>It's bad form to write code like that, but it demonstrates the point: you can use the value of one expression in another expression. This isn't a new idea; you've likely used the return value of a function in a list or as an argument to another function before. You may not have realized its implications.</p>
<div id="iregex__icapture_0"></div>
<p>Suppose you have a whole name and you want to extract the first name. This is easy to do with a regular expression:</p>
<div class="programlisting">
<pre>
<code>    my ($first_name) = $name =~ /($first_name_rx)/;</code>
</pre></div>
<p>... where <code>$first_name_rx</code> is a precompiled regular expression. In list context, a successful regex match returns a list of all captures, and Perl assigns the first one to <code>$first_name</code>.</p>
<p>Now imagine if you want to modify the name, perhaps removing all non-word characters to create a useful username for a system account. You can write:</p>
<div class="programlisting">
<pre>
<code>    (my $normalized_name = $name) =~ tr/A-Za-z//dc;</code>
</pre></div>
<p>Unlike the previous example, this one reads right to left. First, assign the value of <code>$name</code> to <code>$normalized_name</code>. Then, perform the transliteration on <code>$normalized_name</code> <span class="footnote">(footnote: The parentheses here affect the precedence so that the assignment happens first.)</span>. The assignment expression evaluates to the <i>variable</i> <code>$normalized_name</code>. This technique works on all sorts of in-place modification operators:</p>
<div class="programlisting">
<pre>
<code>    my $age = 14;
    (my $next_age = $age)++;

    say "Next year I will be $next_age";</code>
</pre></div>
<h4 id="heading_id_12">Unary Coercions</h4>
<div id="unary_coercions"></div>
<div id="icoercion_1"></div>
<div id="itypes_0"></div>
<p>Perl 5's type system often does the right thing, at least if you choose the correct operators. To concatenate strings, use the string concatenation operator, and Perl will treat both scalars as strings. To add two numbers, use the addition operator and Perl will treat both scalars as numeric.</p>
<p>Sometimes you have to give Perl a hint about what you mean. Several <i>unary coercions</i> exist, by which you can use Perl 5 operators to force the evaluation of a value a specific way.</p>
<div id="iunary_conversions__inumeric_0"></div>
<p>To ensure that Perl treats a value as numeric, add zero:</p>
<div class="programlisting">
<pre>
<code>    my $numeric_value = 0 + $value;</code>
</pre></div>
<div id="iunary_conversions__iboolean_0"></div>
<p>To ensure that Perl treats a value as boolean, double negate it:</p>
<div class="programlisting">
<pre>
<code>    my $boolean_value = !! $value;</code>
</pre></div>
<div id="iunary_conversions__istring_0"></div>
<p>To ensure that Perl treats a value as a string, concatenate it with the empty string:</p>
<div class="programlisting">
<pre>
<code>    my $string_value = '' . $value;</code>
</pre></div>
<p>Though the need for these coercions is vanishingly rare, you should understand these idioms if you encounter them.</p>
<h3 id="heading_id_13">Global Variables</h3>
<div id="globals"></div>
<div id="isuper_globals_0"></div>
<div id="ivariables__isuper_global_0"></div>
<p>Perl 5 provides several <i>super global variables</i> that are truly global, not restricted to any specific package. These super globals have two drawbacks. First, they're global; any direct or indirect modifications may have effects on other parts of the program. Second, they're terse. Experienced Perl 5 programmers have memorized some of them. Few people have memorized all of them. Only a handful are ever useful. <code>perldoc perlvar</code> contains the exhaustive list of such variables.</p>
<h4 id="heading_id_14">Managing Super Globals</h4>
<div id="isuper_globals__imanaging_0"></div>
<div id="ilocal_1"></div>
<p>The best approach to managing the global behavior of these super globals is to avoid using them. When you must use them, use <code>local</code> in the smallest possible scope to constrain any modifications. You are still susceptible to any changes code you <i>call</i> makes to those globals, but you reduce the likelihood of surprising code <i>outside</i> of your scope.</p>
<div class="sidebar">
<p>Workarounds exist for some of this global behavior, but many of these variables have existed since Perl 1 and will continue as part of Perl 5 throughout its lifetime. As the easy file slurping idiom (<a href="chapter_10.html#easy_file_slurping">Easy File Slurping</a>(easy_file_slurping)) demonstrates, this is often possible:</p>
<div class="programlisting">
<pre>
<code>    my $file = do { <b>local $/</b> = &lt;$fh&gt; };</code>
</pre></div>
<p>The effect of <code>local</code>izing <code>$/</code> lasts only through the end of the block. There is a low chance that any Perl code will run as a result of reading lines from the filehandle <span class="footnote">(footnote: A tied filehandle is one of the few possibilities.)</span> and change the value of <code>$/</code> within the <code>do</code> block.</p>
<p>Not all cases of using super globals are this easy to guard, but this often works.</p>
<div id="ieval_1"></div>
<div id="iexceptions__icatching_1"></div>
<p>Other times you need to <i>read</i> the value of a super global and hope that no other code has modified it. Catching exceptions with an <code>eval</code> block can be susceptible to race conditions <span class="footnote">(footnote: Use <code>Try::Tiny</code> instead!)</span>, in that <code>DESTROY()</code> methods invoked on lexicals that have gone out of scope may reset <code>$@</code>:</p>
<div class="programlisting">
<pre>
<code>    local @;

    eval { ... };

    if (<b>my $exception = $@</b>) { ... }</code>
</pre></div>
<p>Copy <code>$@</code> <i>immediately</i> to preserve its contents.</p>
</div>
<h4 id="heading_id_15">English Names</h4>
<div id="ienglish_0"></div>
<p>The core <code>English</code> module provides verbose names for the punctuation-heavy super globals. Import them into a namespace with:</p>
<div class="programlisting">
<pre>
<code>    use English '-no_match_vars';</code>
</pre></div>
<p>Subsequently you can use the verbose names documented in <code>perldoc perlvar</code> within the scope of this namespace.</p>
<div class="sidebar">
<div id="i3638amp59_0"></div>
<div id="iglobals__i3638amp59_0"></div>
<div id="i3696_0"></div>
<div id="iglobals__i3696_0"></div>
<div id="i3638353959_0"></div>
<div id="iglobals__i3638353959_0"></div>
<p>Three regex-related super globals (<code>$&amp;</code>, <code>$`</code>, and <code>$'</code>) impose a global performance penalty for <i>all</i> regular expressions within a program. If you neglect to provide that import flag, your program will suffer the penalty even if you don't explicitly read from those variables. This is not the default behavior for backwards-compatibility concerns.</p>
<p>Modern Perl programs should use the <code>@-</code> variable as a replacement for the terrible three.</p>
</div>
<h4 id="heading_id_16">Useful Super Globals</h4>
<div id="isuper_globals__iuseful_0"></div>
<p>Most modern Perl 5 programs can get by with using only a couple of the super globals. Several exist for special circumstances you're unlikely to encounter. While <code>perldoc perlvar</code> is the canonical documentation for most of these variables, some deserve special mention.</p>
<i>Table: Super Globals</i>
<div class="author">
<p>... or characters, in a Unicode mode?</p>
</div>
<p>Many places within Perl 5 itself make system calls without your knowledge. The value of this variable can change out from under you, so copy it <i>immediately</i> after making such a call yourself.</p>
<table>
<tr>
<th>Global</th>
<th>English name</th>
<th>Description</th>
</tr>
<tr>
<td><code>$/</code></td>
<td><code>$INPUT_RECORD_SEPARATOR</code></td>
<td>A string of zero or more characters which denotes the end of a record when reading input a line at a time. By default, this is your platform-specific newline character sequence. If you undefine this value, Perl will attempt to read the entire file into memory. If you set this value to a <i>reference</i> to an integer, Perl will try to read that many <i>bytes</i> per record.</td>
</tr>
<tr>
<td><code>$.</code></td>
<td><code>$INPUT_LINE_NUMBER</code></td>
<td>The current line (more accurately, <i>record</i>) number read from the most recently-accessed filehandle. You can read from this variable, but writing to it has no effect. Localizing this variable will localize the filehandle to which it refers.</td>
</tr>
<tr>
<td><code>$|</code></td>
<td><code>$OUTPUT_AUTOFLUSH</code></td>
<td>The boolean value of this variable governs whether Perl will flush everything written to the currently selected filehandle immediately or only when Perl's buffer is full. Unbuffered output is useful when writing to a pipe or socket or terminal which should not block waiting for input.</td>
</tr>
<tr>
<td><code>@ARGV</code></td>
<td>(none)</td>
<td>The command-line arguments passed to the program.</td>
</tr>
<tr>
<td><code>$!</code></td>
<td><code>$ERRNO</code></td>
<td>A dualvar (<a href="chapter_03.html#dualvars">Dualvars</a>(dualvars)) which contains the result of the <i>most recent</i> system call. In numeric context, this corresponds to C's <code>errno</code> value, where anything other than zero indicates some kind of error. In string context, returns the appropriate system error string. Localize this variable before performing a system call (implicitly or explicitly) to avoid overwriting the appropriate value for other code elsewhere.</td>
</tr>
<tr>
<td><code>$"</code></td>
<td><code>$LIST_SEPARATOR</code></td>
<td>A string used to separate array and list elements interpolated into a string.</td>
</tr>
<tr>
<td><code>%+</code></td>
<td>(none)</td>
<td>The variable containing named captures from successful regular expression matches (<a href="chapter_06.html#named_captures">Named Captures</a>(named_captures)).</td>
</tr>
<tr>
<td><code>$@</code></td>
<td><code>$EVAL_ERROR</code></td>
<td>The value thrown from the most recent exception (<a href="chapter_09.html#catching_exceptions">Catching Exceptions</a>(catching_exceptions)).</td>
</tr>
<tr>
<td><code>$0</code></td>
<td><code>$PROGRAM_NAME</code></td>
<td>The name of the program currently executing. You may modify this value on some Unix-like platforms to change the name of the program as it appears to other programs on the system, such as <code>ps</code> or <code>top</code>.</td>
</tr>
<tr>
<td><code>$$</code></td>
<td><code>$PID</code></td>
<td>The process id of the currently running instance of the program, as the operating system understands it. This will vary between <code>fork()</code>ed programs and may vary between threads in the same program.</td>
</tr>
<tr>
<td><code>@INC</code></td>
<td>(none)</td>
<td>A list of filesystem paths in which Perl will look for files to load with <code>use</code> or <code>require</code>. See <code>perldoc -f require</code> for other items this array can contain.</td>
</tr>
<tr>
<td><code>%SIG</code></td>
<td>(none)</td>
<td>A hash which maps OS and low-level Perl signals to function references used to handle those signals. Trap the standard Ctrl-C interrupt by catching the <code>INT</code> signal, for example. See <code>perldoc perlipc</code> for more information about signals and especially safe signals.</td>
</tr>
<tr>
<td></td>
</tr>
</table>
<h4 id="heading_id_17">Alternatives to Super Globals</h4>
<div id="isuper_globals__ialternatives_0"></div>
<p>The worst culprits for action at a distance relate to IO and exceptional conditions. Using <code>Try::Tiny</code> (<a href="chapter_09.html#exception_caveats">Exception Caveats</a>(exception_caveats)) will help insulate you from the tricky semantics of proper exception handling. <code>local</code>izing and copying the value of <code>$!</code> can help you avoid strange behaviors when Perl makes implicit system calls.</p>
<p>You can use methods on lexical filehandles (<a href="chapter_03.html#lexical_filehandles">Filehandle References</a>(lexical_filehandles)) rather than IO-related super globals by <code>use</code>ing <code>IO::Handle</code>. In place of <code>select</code>ing a filehandle, then manipulating <code>$|</code>, call the <code>autoflush()</code> method on the lexical filehandle directly. Use the <code>input_line_number()</code> method to get the equivalent of <code>$.</code> for that specific filehandle. See the <code>IO::Handle</code> documentation for other appropriate methods.</p>
</body>
</html>
